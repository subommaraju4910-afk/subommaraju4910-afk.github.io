<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Squat Fix</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.10.14"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <style>
    body { background:#f6f6f6; font-family:Arial; margin:0; }
    .container { width:90%; max-width:1000px; margin:auto; padding:20px; }
    canvas { width:100%; background:black; border-radius:10px; }
    .dropzone { border:3px dashed #ccc; padding:40px; text-align:center; border-radius:15px; background:white; cursor:pointer;}
    .btn { padding:10px 20px; border-radius:8px; border:none; cursor:pointer; color:white; font-size:16px; }
    .purple{ background:#8a85ff; } .green{ background:#6acb8a; } .red{ background:#ff7b7b; } .gray{ background:#444; }
    #loadingBar { height:12px; background:#ddd; border-radius:10px; overflow:hidden; }
    #loadingBar div { height:100%; width:0%; background:#8a85ff; transition:0.3s; }
  </style>
</head>

<body>
<div class="container" x-data="poseApp()" x-init="initPose()">

  <h1 style="text-align:center;">Squat Fix</h1>
  <p style="text-align:center; margin-top:-10px;">AI shows <b>exactly</b> what you're doing wrong</p>

  <!-- DROPZONE -->
  <div class="dropzone" @click="$refs.file.click()" @dragover.prevent @drop.prevent="handleDrop">
    <p>⬆️ <br> Drop photo or video <br> or click to upload</p>
    <input type="file" x-ref="file" accept="image/*,video/*" @change="handleFile" hidden>
  </div>

  <!-- BUTTONS -->
  <div style="margin-top:20px; display:flex; gap:10px; justify-content:center;">
    <button class="btn purple" @click="analyze()">Analyze</button>
    <button class="btn green" @click="startCamera()">Live Camera</button>
    <button class="btn red" @click="stopCamera()">Stop</button>
    <button class="btn gray" @click="clearAll()">Clear</button>
  </div>

  <!-- LOADING BAR -->
  <div id="loadingBar" style="margin-top:20px;">
    <div id="loadingFill"></div>
  </div>

  <p x-show="loading" style="text-align:center; margin-top:10px;">Loading AI...</p>

  <!-- CANVAS -->
  <canvas x-ref="canvas" style="margin-top:20px;"></canvas>

  <!-- OUTPUT -->
  <div style="margin-top:20px; background:white; padding:20px; border-radius:10px;">
    <h3>Analysis</h3>
    <pre x-text="analysisText || 'No analysis yet.'"></pre>
  </div>

</div>

<script>
function poseApp() {
  return {

    pose: null,
    canvas: null,
    ctx: null,
    stream: null,
    loading: true,
    file: null,
    analysisText: "",
    videoEl: null,

    async initPose() {
      this.canvas = this.$refs.canvas;
      this.ctx = this.canvas.getContext("2d");

      const base = "https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.10.14";

      this.pose = new Pose({
        locateFile: (f) => `${base}/${f}`
      });

      this.pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6,
        selfieMode: false,
        modelAssetPath: `${base}/pose_landmark_full.tflite`,
        wasmLoaderPath: `${base}/pose_solution_packed_assets_loader.js`,
        wasmBinaryPath: `${base}/pose_solution_packed_assets_wasm_bin`
      });

      this.pose.onResults((r) => this.onPoseResults(r));

      setTimeout(() => {
        this.loading = false;
        document.querySelector("#loadingFill").style.width = "100%";
      }, 600);
    },

    async waitForPose(image) {
      return new Promise((resolve) => {
        const handler = (results) => {
          this.pose.off("results", handler);
          resolve(results);
        };
        this.pose.onResults(handler);
        this.pose.send({ image });
      });
    },

    async handleFile(e) {
      this.file = e.target.files[0];
    },

    handleDrop(e) {
      this.file = e.dataTransfer.files[0];
    },

    async analyze() {
      if (!this.file) return alert("Upload a file first!");

      const url = URL.createObjectURL(this.file);

      if (this.file.type.startsWith("image")) {
        const img = new Image();
        img.onload = async () => {
          this.canvas.width = img.width;
          this.canvas.height = img.height;

          const results = await this.waitForPose(img);
          this.onPoseResults(results);
        };
        img.src = url;
      }

      else if (this.file.type.startsWith("video")) {
        this.videoEl = document.createElement("video");
        this.videoEl.src = url;
        this.videoEl.loop = false;

        this.videoEl.onloadeddata = () => {
          this.videoEl.play();
          this.processVideoFrame();
        };
      }
    },

    async processVideoFrame() {
      if (!this.videoEl || this.videoEl.paused || this.videoEl.ended) return;

      const results = await this.waitForPose(this.videoEl);
      this.onPoseResults(results);

      requestAnimationFrame(() => this.processVideoFrame());
    },

    async startCamera() {
      this.stream = await navigator.mediaDevices.getUserMedia({ video: true });
      this.videoEl = document.createElement("video");
      this.videoEl.srcObject = this.stream;
      this.videoEl.play();

      this.processVideoFrame();
    },

    stopCamera() {
      if (this.stream) this.stream.getTracks().forEach(t => t.stop());
      this.stream = null;
    },

    clearAll() {
      this.analysisText = "";
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },

    onPoseResults(results) {
      if (!results.poseLandmarks) return;

      const img = results.image;

      this.canvas.width = img.width || img.videoWidth;
      this.canvas.height = img.height || img.videoHeight;

      this.ctx.drawImage(img, 0, 0, this.canvas.width, this.canvas.height);

      const lm = results.poseLandmarks.map(l => ({...l}));

      this.drawSkeleton(lm);
      this.analysisText = this.analyzeSquat(lm);
    },

    drawSkeleton(lm) {
      const pairs = [
        [11,13],[13,15],
        [12,14],[14,16],
        [23,25],[25,27],
        [24,26],[26,28]
      ];

      this.ctx.strokeStyle = "cyan";
      this.ctx.lineWidth = 4;

      pairs.forEach(([a,b]) => {
        const p1 = lm[a], p2 = lm[b];
        this.ctx.beginPath();
        this.ctx.moveTo(p1.x*this.canvas.width, p1.y*this.canvas.height);
        this.ctx.lineTo(p2.x*this.canvas.width, p2.y*this.canvas.height);
        this.ctx.stroke();
      });
    },

    analyzeSquat(lm) {
      const angle = (A,B,C) => {
        const dx1=A.x-B.x, dy1=A.y-B.y;
        const dx2=C.x-B.x, dy2=C.y-B.y;
        const dot=dx1*dx2+dy1*dy2;
        const m1=Math.hypot(dx1,dy1);
        const m2=Math.hypot(dx2,dy2);
        return Math.acos(dot/(m1*m2))*180/Math.PI;
      };

      const R = angle(lm[23],lm[25],lm[27]);
      const L = angle(lm[24],lm[26],lm[28]);

      let out = `Right knee: ${R.toFixed(1)}°\nLeft knee: ${L.toFixed(1)}°\n\n`;

      const avg = (R+L)/2;
      if (avg < 70) out += "❗ Go deeper — knees not bending enough";
      else if (avg > 150) out += "❗ Standing too upright — no squat detected";
      else out += "✅ Good squat depth";

      return out;
    },

  };
}
</script>

</body>
</html>
