<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Squat Fix – AI Coach</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.10.14/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.10.14/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js" defer></script>
  <style>
    /* your styles here - unchanged */
  </style>
</head>
<body>
  <div class="c" x-data="app()" x-init="init()">
    <h1>Squat Fix</h1>
    <p class="sub">AI shows <b>exactly</b> what you're doing wrong — <b>upload fixed</b></p>

    <div class="drop"
      @dragover.prevent="drag=true"
      @dragleave.prevent="drag=false"
      @drop.prevent="handleDrop($event)"
      :class="drag ? 'dragover' : ''"
      @click="$refs.file.click()">
      <p style="font-size:32px; margin:0;">⬆️ Upload</p>
      <p>Drop photo or video here<br /><small>or click to browse</small></p>
      <input type="file" x-ref="file" accept="image/*,video/*" @change="handleFileChange($event)" hidden />
    </div>

    <div style="display:flex; justify-content:center; flex-wrap:wrap;">
      <button class="btn p" @click="startAnalyze()" :disabled="!file || loading">Analyze</button>
      <button class="btn g" @click="startCam()" :disabled="cam || loading">Live Camera</button>
      <button class="btn r" @click="stopCam()" :disabled="!cam">Stop</button>
      <button class="btn gray" @click="clear()">Clear</button>
    </div>

    <div id="bar" x-show="loading" style="margin-top: 20px;">
      <div id="fill" :style="{ width: prog + '%' }"></div>
    </div>
    <p x-show="loading" style="text-align:center; margin-top:8px; color:#666;">
      <span x-text="msg"></span> <span x-text="prog + '%'"></span>
    </p>

    <canvas x-ref="canv" style="margin-top:20px; border-radius:12px; box-shadow:0 4px 12px rgba(0,0,0,0.1); background:#111;"></canvas>

    <div class="res" x-show="result">
      <h3 style="margin-top:0; color:#4a47a3;">Form Feedback</h3>
      <template x-for="item in result.items" :key="item.title">
        <div :class="item.type" class="issue">
          <strong x-text="item.title"></strong><br />
          <span x-text="item.msg"></span>
        </div>
      </template>
    </div>
  </div>

<script>
function app() {
  return {
    pose: null,
    canv: null,
    ctx: null,
    file: null,
    cam: false,
    camera: null,
    loading: false,
    prog: 0,
    msg: '',
    result: null,
    drag: false,

    init() {
      this.canv = this.$refs.canv;
      this.ctx = this.canv.getContext('2d');

      const basePath = 'https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.10.14/';
      this.pose = new Pose({
        locateFile: file => basePath + file,
      });

      this.pose.setOptions({
        modelComplexity: 0,
        smoothLandmarks: true,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7,
      });

      // Attach onResults only once here
      this.pose.onResults(results => this.onResults(results));
    },

    handleDrop(event) {
      this.drag = false;
      const files = event.dataTransfer.files;
      if (files.length > 0) {
        this.file = files[0];
      }
    },

    handleFileChange(event) {
      const files = event.target.files;
      if (files.length > 0) {
        this.file = files[0];
      }
    },

    async startAnalyze() {
      if (!this.file) return;
      this.loading = true;
      this.prog = 0;
      this.msg = 'Loading...';
      this.result = null;

      const url = URL.createObjectURL(this.file);
      this.prog = 20;
      this.msg = 'Reading file...';

      if (this.file.type.startsWith('image')) {
        const img = new Image();
        img.crossOrigin = 'anonymous';
        img.onload = async () => {
          this.canv.width = img.naturalWidth;
          this.canv.height = img.naturalHeight;
          this.ctx.drawImage(img, 0, 0);
          this.prog = 60;
          this.msg = 'Analyzing image...';
          await this.pose.send({ image: img });
          this.done(url);
        };
        img.onerror = () => {
          this.error('Image failed to load', url);
        };
        img.src = url;
      } else if (this.file.type.startsWith('video')) {
        const vid = document.createElement('video');
        vid.src = url;
        vid.crossOrigin = 'anonymous';
        vid.muted = true;
        vid.playsInline = true;

        vid.onloadedmetadata = async () => {
          const frames = [0.3, 0.7];
          let bestScore = -Infinity;
          let bestResult = null;

          for (let i = 0; i < frames.length; i++) {
            vid.currentTime = vid.duration * frames[i];
            await new Promise(resolve => {
              vid.onseeked = resolve;
            });

            this.prog = 40 + ((i + 1) * 25);
            this.msg = `Analyzing frame ${i + 1} / 2...`;

            await this.pose.send({ image: vid });

            if (this.result && this.result.score > bestScore) {
              bestScore = this.result.score;
              bestResult = JSON.parse(JSON.stringify(this.result));
            }
          }

          this.result = bestResult || {
            items: [{ type: 'minor', title: 'No squat', msg: 'Could not detect form.' }],
            score: 0,
          };
          this.done(url);
        };

        vid.onerror = () => {
          this.error('Video failed to load', url);
        };
      } else {
        this.error('Unsupported file type', url);
      }
    },

    onResults(results) {
      if (!results.poseLandmarks) {
        this.result = null;
        return;
      }

      const img = results.image;
      this.canv.width = img.videoWidth || img.naturalWidth || img.width;
      this.canv.height = img.videoHeight || img.naturalHeight || img.height;

      this.ctx.clearRect(0, 0, this.canv.width, this.canv.height);
      this.ctx.drawImage(img, 0, 0, this.canv.width, this.canv.height);

      const landmarks = results.poseLandmarks.map(lm => ({ ...lm }));
      this.drawSkeleton(landmarks);

      // Analyze pose landmarks for squat feedback
      this.result = this.analyzePose(landmarks);
    },

    drawSkeleton(landmarks) {
      const pairs = [
        [11, 13], [13, 15], [12, 14], [14, 16], [11, 12],
        [23, 24], [23, 25], [25, 27], [24, 26], [26, 28],
      ];
      this.ctx.strokeStyle = '#00ffff';
      this.ctx.lineWidth = 5;

      pairs.forEach(([a, b]) => {
        const p1 = landmarks[a];
        const p2 = landmarks[b];
        if (p1.visibility > 0.6 && p2.visibility > 0.6) {
          this.ctx.beginPath();
          this.ctx.moveTo(p1.x * this.canv.width, p1.y * this.canv.height);
          this.ctx.lineTo(p2.x * this.canv.width, p2.y * this.canv.height);
          this.ctx.stroke();
        }
      });
    },

    analyzePose(landmarks) {
      const L = i => landmarks[i];
      const hip = { x: (L(23).x + L(24).x) / 2, y: (L(23).y + L(24).y) / 2 };
      const ankle = { y: (L(27).y + L(28).y) / 2 };
      const kneeL = L(25), kneeR = L(26);
      const shoulder = { x: (L(11).x + L(12).x) / 2, y: (L(11).y + L(12).y) / 2 };

      const legLen = ((L(23).y - L(27).y) + (L(24).y - L(28).y)) / 2;
      const depth = Math.round(((ankle.y - hip.y) / legLen) * 100);

      const torso = { x: shoulder.x - hip.x, y: shoulder.y - hip.y };
      const backAngle = Math.round(
        Math.acos(Math.abs(torso.y) / Math.hypot(torso.x, torso.y)) * (180 / Math.PI)
      );

      const drift = Math.round(
        (Math.abs(kneeL.x - L(27).x) + Math.abs(kneeR.x - L(28).x)) / 2 * 60
      );

      const issues = [];
      let score = 100;

      if (depth < 40) {
        score -= 35;
        issues.push({ type: 'major', title: 'Too High', msg: 'Drop hips below knees!' });
      } else if (depth < 70) {
        score -= 10;
        issues.push({ type: 'minor', title: 'Shallow', msg: 'Go 2–3" deeper.' });
      }

      if (backAngle > 35) {
        score -= 25;
        issues.push({ type: 'major', title: 'Back Leaning', msg: 'Chest up!' });
      } else if (backAngle > 20) {
        score -= 10;
        issues.push({ type: 'minor', title: 'Slight Lean', msg: 'Stay upright.' });
      }

      if (drift > 10) {
        score -= 20;
        issues.push({ type: 'major', title: 'Knees Forward', msg: `${drift}cm past toes!` });
      }

      if (issues.length === 0) {
        issues.push({ type: 'good', title: 'Perfect!', msg: 'Great form!' });
      }

      return { items: issues, score: Math.max(0, Math.round(score)) };
    },

    error(message, url) {
      this.result = { items: [{ type: 'major', title: 'Error', msg: message }] };
      this.loading = false;
      URL.revokeObjectURL(url);
    },

    done(url) {
      this.loading = false;
      this.prog = 100;
      this.msg = 'Done!';
      URL.revokeObjectURL(url);
    },

    async startCam() {
      this.clear();
      this.cam = true;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ video: true });
        const video = document.createElement('video');
        video.srcObject = stream;
        video.play();

        this.camera = new Camera(video, {
          onFrame: async () => {
            await this.pose.send({ image: video });
          },
          width: 640,
          height: 480,
          fps: 30,
        });

        this.camera.start();
      } catch (e) {
        this.result = { items: [{ type: 'major', title: 'Camera Error', msg: 'Allow camera access.' }] };
        this.cam = false;
      }
    },

    stopCam() {
      if (this.camera) this.camera.stop();
      this.cam = false;
      this.result = null;
    },

    clear() {
      this.stopCam();
      this.ctx.clearRect(0, 0, this.canv.width, this.canv.height);
      this.result = null;
      this.file = null;
      this.loading = false;
      this.prog = 0;
      this.msg = '';
    },
  };
}
</script>
</body>
</html>
